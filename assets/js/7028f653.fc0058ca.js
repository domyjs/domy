"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3760],{1184:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(4041);const c={},l=a.createContext(c);function s(e){const n=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),a.createElement(l.Provider,{value:n},e.children)}},1983:(e,n,t)=>{t.d(n,{A:()=>s});var a=t(4041);const c="demo_TaPm";var l=t(1085);const s=({code:e,domy:n,components:s,config:o,plugins:i})=>{const r=(0,a.useRef)(null),[d,h]=(0,a.useState)(!1);return(0,a.useEffect)((()=>{let a=!0;h(!0);return(async()=>{try{if(!r.current||"undefined"==typeof window)return;const{default:a}=await t.e(5228).then(t.t.bind(t,2847,23));window.DOMY||(window.DOMY=a),console.log("DOMY"),r.current.innerHTML=e;const c=i?await i():[];a.createApp(n).configure(o??{}).plugins(c).components(s?.()).mount(r.current)}catch(a){console.error("[Demo] Load error:",a)}})(),()=>{a=!1}}),[d]),d?(0,l.jsx)("div",{className:c,ref:r}):(0,l.jsx)("div",{className:c,children:"Loading..."})}},2474:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var a=t(1085),c=t(1184),l=t(1983);const s={},o="Reactivity",i={id:"essentials/reactivity",title:"Reactivity",description:"DOMY provides a reactive system that allows components to manage state dynamically. This system includes signal, watch, watchEffect, globalWatch, computed, matchPath, and skipReactive to facilitate efficient state management.",source:"@site/docs/essentials/reactivity.mdx",sourceDirName:"essentials",slug:"/essentials/reactivity",permalink:"/domy/docs/essentials/reactivity",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Lifecycle",permalink:"/domy/docs/essentials/lifecycle"},next:{title:"Store",permalink:"/domy/docs/essentials/store"}},r={},d=[{value:"signal",id:"signal",level:2},{value:"Example:",id:"example",level:3},{value:"Usage in a Component:",id:"usage-in-a-component",level:3},{value:"watch",id:"watch",level:2},{value:"Example:",id:"example-1",level:3},{value:"watchEffect",id:"watcheffect",level:2},{value:"Example:",id:"example-2",level:3},{value:"globalWatch",id:"globalwatch",level:2},{value:"Example:",id:"example-3",level:3},{value:"computed",id:"computed",level:2},{value:"Example:",id:"example-4",level:3},{value:"matchPath",id:"matchpath",level:2},{value:"Example:",id:"example-5",level:3},{value:"skipReactive",id:"skipreactive",level:2},{value:"Example:",id:"example-6",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,c.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"reactivity",children:"Reactivity"}),"\n",(0,a.jsxs)(n.p,{children:["DOMY provides a ",(0,a.jsx)(n.strong,{children:"reactive system"})," that allows components to manage state dynamically. This system includes ",(0,a.jsx)(n.code,{children:"signal"}),", ",(0,a.jsx)(n.code,{children:"watch"}),", ",(0,a.jsx)(n.code,{children:"watchEffect"}),", ",(0,a.jsx)(n.code,{children:"globalWatch"}),", ",(0,a.jsx)(n.code,{children:"computed"}),", ",(0,a.jsx)(n.code,{children:"matchPath"}),", and ",(0,a.jsx)(n.code,{children:"skipReactive"})," to facilitate efficient state management."]}),"\n",(0,a.jsx)(n.h2,{id:"signal",children:"signal"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"signal"})," function creates a ",(0,a.jsx)(n.strong,{children:"reactive state"})," that updates when its value changes."]}),"\n",(0,a.jsx)(n.h3,{id:"example",children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { signal } = DOMY;\nconst count = signal(0);\n\nconsole.log(count.value); // 0\ncount.value++;\nconsole.log(count.value); // 1\n"})}),"\n",(0,a.jsx)(n.h3,{id:"usage-in-a-component",children:"Usage in a Component:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-html",children:'<p>Compteur: {{ count }}</p>\n<button @click="count++">+</button>\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const count = signal(0);\n"})}),"\n",(0,a.jsx)(l.A,{code:'\n<p>Count: {{ count }}</p>\n<button @click="count++">+</button>\n',domy:()=>{const{signal:e}=DOMY;return{count:e(0)}}}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"watch",children:"watch"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"watch"})," function observes a ",(0,a.jsx)(n.strong,{children:"specific signal"})," and runs a callback when its value changes."]}),"\n",(0,a.jsx)(n.h3,{id:"example-1",children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { signal, watch } = DOMY;\n\nconst count = signal(0);\n\nwatch(\n  ({ prevValue, newValue }) => {\n    console.log(`Count changed from ${prevValue} to ${newValue}`);\n  },\n  () => count\n);\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"watcheffect",children:"watchEffect"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"watchEffect"})," function automatically tracks ",(0,a.jsx)(n.strong,{children:"reactive dependencies"})," and runs a callback when any of them change."]}),"\n",(0,a.jsx)(n.h3,{id:"example-2",children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const { signal, watchEffect } = DOMY;\n\nconst count = signal(0);\n\nwatchEffect(() => {\n  console.log(`Count updated: ${count.value}`);\n});\n\ncount.value++; // Logs "Count updated: 1"\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"globalwatch",children:"globalWatch"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"globalWatch"})," function works ",(0,a.jsx)(n.strong,{children:"like watch"}),", but listens all signals. It's really usefull for debugging."]}),"\n",(0,a.jsx)(n.h3,{id:"example-3",children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { globalWatch } = DOMY;\n\nglobalWatch(({ prevValue, newValue }) => {\n  console.log(`Something changed from ${prevValue} to ${newValue}`);\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"computed",children:"computed"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"computed"})," function creates a ",(0,a.jsx)(n.strong,{children:"derived reactive value"})," that updates automatically when its dependencies change."]}),"\n",(0,a.jsx)(n.h3,{id:"example-4",children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { signal, computed } = DOMY;\n\nconst count = signal(0);\nconst doubleCount = computed(() => count.value * 2);\n\nconsole.log(doubleCount.value); // 0\ncount.value++;\nconsole.log(doubleCount.value); // 2\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can also define a setter for this computed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { signal, computed } = DOMY;\n\nconst count = signal(0);\nconst doubleCount = computed(\n  () => count.value * 2,\n  newValue => (count.value = newValue / 2)\n);\n\nconsole.log(count.value); // 0\ndoubleCount.value = 2;\nconsole.log(doubleCount.value); // 2\nconsole.log(count.value); // 1\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"matchpath",children:"matchPath"}),"\n",(0,a.jsxs)(n.p,{children:["When managing reactive state, monitoring every change in a complex object can be inefficient.\n",(0,a.jsx)(n.code,{children:"matchPath"})," helps filter updates dynamically, executing logic only when relevant parts of the state are modified."]}),"\n",(0,a.jsx)(n.h3,{id:"example-5",children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { signal, watch, matchPath } = DOMY;\n\nconst state = signal({\n  todos: [{ isComplete: false }, { isComplete: true }]\n});\n\n// Watching for changes in todos using matchPath\nwatch(\n  ({ prevValue, newValue, path }) => {\n    if (matchPath('todos.*.isComplete', path).isMatching) {\n      console.log(`Updated path: ${path}, New Value: ${newValue}`);\n    }\n  },\n  () => state\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:"It also allow to get the params from a path:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { signal, watch, matchPath } = DOMY;\n\nconst state = signal({\n  todos: [{ isComplete: false }, { isComplete: true }]\n});\n\n// Watching for changes in todos using matchPath\nwatch(\n  ({ prevValue, newValue, path }) => {\n    const matcher = matchPath('todos.{index}.isComplete', path);\n    if (matcher.isMatching) {\n      console.log(`Updated path: ${path}, New Value: ${newValue}, Index: ${matcher.params.index}`);\n    }\n  },\n  () => state\n);\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"skipreactive",children:"skipReactive"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"skipReactive"})," function allows you to ",(0,a.jsx)(n.strong,{children:"skip tracking reactive properties"}),", preventing unnecessary updates."]}),"\n",(0,a.jsx)(n.h3,{id:"example-6",children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { signal, skipReactive } = DOMY;\n\n// In the example below, DOMY won't listen to any change make on roles\nconst user = signal({ name: 'Alice', roles: skipReactive(['admin']) });\n"})})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);