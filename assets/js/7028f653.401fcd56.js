"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3760],{3191:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"essentials/reactivity","title":"Reactivity","description":"DOMY provides a reactive system that allows components to manage state dynamically. This system includes signal, watch, watchEffect, globalWatch, computed, matchPath, and skipReactive to facilitate efficient state management.","source":"@site/docs/essentials/reactivity.mdx","sourceDirName":"essentials","slug":"/essentials/reactivity","permalink":"/domy/docs/essentials/reactivity","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Lifecycle","permalink":"/domy/docs/essentials/lifecycle"},"next":{"title":"Store","permalink":"/domy/docs/essentials/store"}}');var l=a(1085),s=a(1184),c=a(1983);const i={},o="Reactivity",h={},d=[{value:"signal",id:"signal",level:2},{value:"Example:",id:"example",level:3},{value:"Usage in a Component:",id:"usage-in-a-component",level:3},{value:"watch",id:"watch",level:2},{value:"Example:",id:"example-1",level:3},{value:"watchEffect",id:"watcheffect",level:2},{value:"Example:",id:"example-2",level:3},{value:"globalWatch",id:"globalwatch",level:2},{value:"Example:",id:"example-3",level:3},{value:"computed",id:"computed",level:2},{value:"Example:",id:"example-4",level:3},{value:"matchPath",id:"matchpath",level:2},{value:"Example:",id:"example-5",level:3},{value:"skipReactive",id:"skipreactive",level:2},{value:"Example:",id:"example-6",level:3}];function r(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"reactivity",children:"Reactivity"})}),"\n",(0,l.jsxs)(n.p,{children:["DOMY provides a ",(0,l.jsx)(n.strong,{children:"reactive system"})," that allows components to manage state dynamically. This system includes ",(0,l.jsx)(n.code,{children:"signal"}),", ",(0,l.jsx)(n.code,{children:"watch"}),", ",(0,l.jsx)(n.code,{children:"watchEffect"}),", ",(0,l.jsx)(n.code,{children:"globalWatch"}),", ",(0,l.jsx)(n.code,{children:"computed"}),", ",(0,l.jsx)(n.code,{children:"matchPath"}),", and ",(0,l.jsx)(n.code,{children:"skipReactive"})," to facilitate efficient state management."]}),"\n",(0,l.jsx)(n.h2,{id:"signal",children:"signal"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"signal"})," function creates a ",(0,l.jsx)(n.strong,{children:"reactive state"})," that updates when its value changes."]}),"\n",(0,l.jsx)(n.h3,{id:"example",children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const { signal } = DOMY;\nconst count = signal(0);\n\nconsole.log(count.value); // 0\ncount.value++;\nconsole.log(count.value); // 1\n"})}),"\n",(0,l.jsx)(n.h3,{id:"usage-in-a-component",children:"Usage in a Component:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-html",children:'<p>Compteur: {{ count }}</p>\n<button @click="count++">+</button>\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const count = signal(0);\n"})}),"\n",(0,l.jsx)(c.A,{code:'\n<p>Count: {{ count }}</p>\n<button @click="count++">+</button>\n',domy:()=>{const{signal:e}=DOMY;return{count:e(0)}}}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"watch",children:"watch"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"watch"})," function observes a ",(0,l.jsx)(n.strong,{children:"specific signal"})," and runs a callback when its value changes."]}),"\n",(0,l.jsx)(n.h3,{id:"example-1",children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const { signal, watch } = DOMY;\n\nconst count = signal(0);\n\nwatch(\n  ({ prevValue, newValue }) => {\n    console.log(`Count changed from ${prevValue} to ${newValue}`);\n  },\n  () => count\n);\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"watcheffect",children:"watchEffect"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"watchEffect"})," function automatically tracks ",(0,l.jsx)(n.strong,{children:"reactive dependencies"})," and runs a callback when any of them change."]}),"\n",(0,l.jsx)(n.h3,{id:"example-2",children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'const { signal, watchEffect } = DOMY;\n\nconst count = signal(0);\n\nwatchEffect(() => {\n  console.log(`Count updated: ${count.value}`);\n});\n\ncount.value++; // Logs "Count updated: 1"\n'})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"globalwatch",children:"globalWatch"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"globalWatch"})," function works ",(0,l.jsx)(n.strong,{children:"like watch"}),", but listens all signals. It's really usefull for debugging."]}),"\n",(0,l.jsx)(n.h3,{id:"example-3",children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const { globalWatch } = DOMY;\n\nglobalWatch(({ prevValue, newValue }) => {\n  console.log(`Something changed from ${prevValue} to ${newValue}`);\n});\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"computed",children:"computed"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"computed"})," function creates a ",(0,l.jsx)(n.strong,{children:"derived reactive value"})," that updates automatically when its dependencies change."]}),"\n",(0,l.jsx)(n.h3,{id:"example-4",children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const { signal, computed } = DOMY;\n\nconst count = signal(0);\nconst doubleCount = computed(() => count.value * 2);\n\nconsole.log(doubleCount.value); // 0\ncount.value++;\nconsole.log(doubleCount.value); // 2\n"})}),"\n",(0,l.jsx)(n.p,{children:"You can also define a setter for this computed:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const { signal, computed } = DOMY;\n\nconst count = signal(0);\nconst doubleCount = computed(\n  () => count.value * 2,\n  newValue => (count.value = newValue / 2)\n);\n\nconsole.log(count.value); // 0\ndoubleCount.value = 2;\nconsole.log(doubleCount.value); // 2\nconsole.log(count.value); // 1\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"matchpath",children:"matchPath"}),"\n",(0,l.jsxs)(n.p,{children:["When managing reactive state, monitoring every change in a complex object can be inefficient.\n",(0,l.jsx)(n.code,{children:"matchPath"})," helps filter updates dynamically, executing logic only when relevant parts of the state are modified."]}),"\n",(0,l.jsx)(n.h3,{id:"example-5",children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const { signal, watch, matchPath } = DOMY;\n\nconst state = signal({\n  todos: [{ isComplete: false }, { isComplete: true }]\n});\n\n// Watching for changes in todos using matchPath\nwatch(\n  ({ prevValue, newValue, path }) => {\n    if (matchPath('todos.*.isComplete', path).isMatching) {\n      console.log(`Updated path: ${path}, New Value: ${newValue}`);\n    }\n  },\n  () => state\n);\n"})}),"\n",(0,l.jsx)(n.p,{children:"It also allow to get the params from a path:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const { signal, watch, matchPath } = DOMY;\n\nconst state = signal({\n  todos: [{ isComplete: false }, { isComplete: true }]\n});\n\n// Watching for changes in todos using matchPath\nwatch(\n  ({ prevValue, newValue, path }) => {\n    const matcher = matchPath('todos.{index}.isComplete', path);\n    if (matcher.isMatching) {\n      console.log(`Updated path: ${path}, New Value: ${newValue}, Index: ${matcher.params.index}`);\n    }\n  },\n  () => state\n);\n"})}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsx)(n.h2,{id:"skipreactive",children:"skipReactive"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"skipReactive"})," function allows you to ",(0,l.jsx)(n.strong,{children:"skip tracking reactive properties"}),", preventing unnecessary updates."]}),"\n",(0,l.jsx)(n.h3,{id:"example-6",children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const { signal, skipReactive } = DOMY;\n\n// In the example below, DOMY won't listen to any change make on roles\nconst user = signal({ name: 'Alice', roles: skipReactive(['admin']) });\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(r,{...e})}):r(e)}}}]);